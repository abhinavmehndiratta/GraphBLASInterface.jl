<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Operations · GraphBLASInterface</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>GraphBLASInterface</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li><a class="toctext" href="../context_methods/">Context methods</a></li><li><a class="toctext" href="../matrix_and_vector_methods/">Basic matrix &amp; vector methods</a></li><li><a class="toctext" href="../algebra_methods/">Operators &amp; algebraic structures</a></li><li><a class="toctext" href="../desc_methods/">Descriptors</a></li><li><a class="toctext" href="../free_methods/">Freeing objects</a></li><li><a class="toctext" href="../seq_ter/">Sequence termination</a></li><li class="current"><a class="toctext" href>Operations</a><ul class="internal"><li><a class="toctext" href="#GraphBLAS-operations-1">GraphBLAS operations</a></li><li><a class="toctext" href="#Multiplication-1">Multiplication</a></li><li><a class="toctext" href="#Element-wise-multiplication-1">Element-wise multiplication</a></li><li><a class="toctext" href="#Element-wise-addition-1">Element-wise addition</a></li><li><a class="toctext" href="#Extract-1">Extract</a></li><li><a class="toctext" href="#Assign-1">Assign</a></li><li><a class="toctext" href="#Apply-1">Apply</a></li><li><a class="toctext" href="#Reduce-1">Reduce</a></li><li><a class="toctext" href="#Transpose-1">Transpose</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Operations</a></li></ul><a class="edit-page" href="https://github.com/abhinavmehndiratta/GraphBLASInterface.jl/blob/master/docs/src/operations.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Operations</span><a class="fa fa-bars" href="#"></a></div></header><h2><a class="nav-anchor" id="GraphBLAS-operations-1" href="#GraphBLAS-operations-1">GraphBLAS operations</a></h2><h2><a class="nav-anchor" id="Multiplication-1" href="#Multiplication-1">Multiplication</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GraphBLASInterface.GrB_mxm" href="#GraphBLASInterface.GrB_mxm"><code>GraphBLASInterface.GrB_mxm</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">GrB_mxm(C, Mask, accum, semiring, A, B, desc)</code></pre><p>Multiplies a matrix with another matrix on a semiring. The result is a matrix.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using GraphBLASInterface, SuiteSparseGraphBLAS

julia&gt; GrB_init(GrB_NONBLOCKING)
GrB_SUCCESS::GrB_Info = 0

julia&gt; A = GrB_Matrix{Int64}()
GrB_Matrix{Int64}

julia&gt; GrB_Matrix_new(A, GrB_INT64, 2, 2)
GrB_SUCCESS::GrB_Info = 0

julia&gt; I1 = ZeroBasedIndex[0, 1]; J1 = ZeroBasedIndex[0, 1]; X1 = [10, 20]; n1 = 2;

julia&gt; GrB_Matrix_build(A, I1, J1, X1, n1, GrB_FIRST_INT64)
GrB_SUCCESS::GrB_Info = 0

julia&gt; B = GrB_Matrix{Int64}()
GrB_Matrix{Int64}

julia&gt; GrB_Matrix_new(B, GrB_INT64, 2, 2)
GrB_SUCCESS::GrB_Info = 0

julia&gt; I2 = ZeroBasedIndex[0, 1]; J2 = ZeroBasedIndex[0, 1]; X2 = [5, 15]; n2 = 2;

julia&gt; GrB_Matrix_build(B, I2, J2, X2, n2, GrB_FIRST_INT64)
GrB_SUCCESS::GrB_Info = 0

julia&gt; C = GrB_Matrix{Int64}()
GrB_Matrix{Int64}

julia&gt; GrB_Matrix_new(C, GrB_INT64, 2, 2)
GrB_SUCCESS::GrB_Info = 0

julia&gt; GrB_mxm(C, GrB_NULL, GrB_NULL, GxB_PLUS_TIMES_INT64, A, B, GrB_NULL)
GrB_SUCCESS::GrB_Info = 0

julia&gt; @GxB_fprint(C, GxB_COMPLETE)

GraphBLAS matrix: C 
nrows: 2 ncols: 2 max # entries: 2
format: standard CSR vlen: 2 nvec_nonempty: 2 nvec: 2 plen: 2 vdim: 2
hyper_ratio 0.0625
GraphBLAS type:  int64_t size: 8
last method used for GrB_mxm, vxm, or mxv: heap
number of entries: 2 
row: 0 : 1 entries [0:0]
    column 0: int64 50
row: 1 : 1 entries [1:1]
    column 1: int64 300</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/abhinavmehndiratta/GraphBLASInterface.jl/blob/5b1613f88ab6669d7f328ee1ba2f6ff68b3cafd6/src/operations/multiplication.jl#L1-L58">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GraphBLASInterface.GrB_vxm" href="#GraphBLASInterface.GrB_vxm"><code>GraphBLASInterface.GrB_vxm</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">GrB_vxm(w, mask, accum, semiring, u, A, desc)</code></pre><p>Multiplies a (row)vector with a matrix on an semiring. The result is a vector.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using GraphBLASInterface, SuiteSparseGraphBLAS

julia&gt; GrB_init(GrB_NONBLOCKING)
GrB_SUCCESS::GrB_Info = 0

julia&gt; A = GrB_Matrix{Int64}()
GrB_Matrix{Int64}

julia&gt; GrB_Matrix_new(A, GrB_INT64, 2, 2)
GrB_SUCCESS::GrB_Info = 0

julia&gt; I1 = ZeroBasedIndex[0, 1]; J1 = ZeroBasedIndex[0, 1]; X1 = [10, 20]; n1 = 2;

julia&gt; GrB_Matrix_build(A, I1, J1, X1, n1, GrB_FIRST_INT64)
GrB_SUCCESS::GrB_Info = 0

julia&gt; u = GrB_Vector{Int64}()
GrB_Vector{Int64}

julia&gt; GrB_Vector_new(u, GrB_INT64, 2)
GrB_SUCCESS::GrB_Info = 0

julia&gt; I2 = ZeroBasedIndex[0, 1]; X2 = [5, 6]; n2 = 2;

julia&gt; GrB_Vector_build(u, I2, X2, n2, GrB_FIRST_INT64)
GrB_SUCCESS::GrB_Info = 0

julia&gt; w = GrB_Vector{Int64}()
GrB_Vector{Int64}

julia&gt; GrB_Vector_new(w, GrB_INT64, 2)
GrB_SUCCESS::GrB_Info = 0

julia&gt; GrB_vxm(w, GrB_NULL, GrB_NULL, GxB_PLUS_TIMES_INT64, u, A, GrB_NULL)
GrB_SUCCESS::GrB_Info = 0

julia&gt; @GxB_fprint(w, GxB_COMPLETE)

GraphBLAS vector: w 
nrows: 2 ncols: 1 max # entries: 2
format: standard CSC vlen: 2 nvec_nonempty: 1 nvec: 1 plen: 1 vdim: 1
hyper_ratio 0.0625
GraphBLAS type:  int64_t size: 8
last method used for GrB_mxm, vxm, or mxv: heap
number of entries: 2 
column: 0 : 2 entries [0:1]
    row 0: int64 50
    row 1: int64 120</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/abhinavmehndiratta/GraphBLASInterface.jl/blob/5b1613f88ab6669d7f328ee1ba2f6ff68b3cafd6/src/operations/multiplication.jl#L69-L125">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GraphBLASInterface.GrB_mxv" href="#GraphBLASInterface.GrB_mxv"><code>GraphBLASInterface.GrB_mxv</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">GrB_mxv(w, mask, accum, semiring, A, u, desc)</code></pre><p>Multiplies a matrix by a vector on a semiring. The result is a vector.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using GraphBLASInterface, SuiteSparseGraphBLAS

julia&gt; GrB_init(GrB_NONBLOCKING)
GrB_SUCCESS::GrB_Info = 0

julia&gt; A = GrB_Matrix{Int64}()
GrB_Matrix{Int64}

julia&gt; GrB_Matrix_new(A, GrB_INT64, 2, 2)
GrB_SUCCESS::GrB_Info = 0

julia&gt; I1 = ZeroBasedIndex[0, 0, 1]; J1 = ZeroBasedIndex[0, 1, 1]; X1 = [10, 20, 30]; n1 = 3;

julia&gt; GrB_Matrix_build(A, I1, J1, X1, n1, GrB_FIRST_INT64)
GrB_SUCCESS::GrB_Info = 0

julia&gt; u = GrB_Vector{Int64}()
GrB_Vector{Int64}

julia&gt; GrB_Vector_new(u, GrB_INT64, 2)
GrB_SUCCESS::GrB_Info = 0

julia&gt; I2 = ZeroBasedIndex[0, 1]; X2 = [5, 6]; n2 = 2;

julia&gt; GrB_Vector_build(u, I2, X2, n2, GrB_FIRST_INT64)
GrB_SUCCESS::GrB_Info = 0

julia&gt; w = GrB_Vector{Int64}()
GrB_Vector{Int64}

julia&gt; GrB_Vector_new(w, GrB_INT64, 2)
GrB_SUCCESS::GrB_Info = 0

julia&gt; GrB_mxv(w, GrB_NULL, GrB_NULL, GxB_PLUS_TIMES_INT64, A, u, GrB_NULL)
GrB_SUCCESS::GrB_Info = 0

julia&gt; @GxB_fprint(w, GxB_COMPLETE)

GraphBLAS vector: w 
nrows: 2 ncols: 1 max # entries: 2
format: standard CSC vlen: 2 nvec_nonempty: 1 nvec: 1 plen: 1 vdim: 1
hyper_ratio 0.0625
GraphBLAS type:  int64_t size: 8
last method used for GrB_mxm, vxm, or mxv: dot
number of entries: 2 
column: 0 : 2 entries [0:1]
    row 0: int64 170
    row 1: int64 180</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/abhinavmehndiratta/GraphBLASInterface.jl/blob/5b1613f88ab6669d7f328ee1ba2f6ff68b3cafd6/src/operations/multiplication.jl#L136-L192">source</a></section><h2><a class="nav-anchor" id="Element-wise-multiplication-1" href="#Element-wise-multiplication-1">Element-wise multiplication</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GraphBLASInterface.GrB_eWiseMult" href="#GraphBLASInterface.GrB_eWiseMult"><code>GraphBLASInterface.GrB_eWiseMult</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">GrB_eWiseMult(C, mask, accum, op, A, B, desc)</code></pre><p>Generic method for element-wise matrix and vector operations: using set intersection.</p><p><code>GrB_eWiseMult</code> computes <code>C&lt;Mask&gt; = accum (C, A .* B)</code>, where pairs of elements in two matrices (or vectors) are pairwise &quot;multiplied&quot; with C(i, j) = mult (A(i, j), B(i, j)). The &quot;multiplication&quot; operator can be any binary operator. The pattern of the result T = A .* B is the set intersection (not union) of A and B. Entries outside of the intersection are not computed. This is primary difference with <code>GrB_eWiseAdd</code>. The input matrices A and/or B may be transposed first, via the descriptor. For a semiring, the mult operator is the semiring&#39;s multiply operator; this differs from the eWiseAdd methods which use the semiring&#39;s add operator instead.</p></div></div><a class="source-link" target="_blank" href="https://github.com/abhinavmehndiratta/GraphBLASInterface.jl/blob/5b1613f88ab6669d7f328ee1ba2f6ff68b3cafd6/src/operations/element_wise_multiplication.jl#L1-L12">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GraphBLASInterface.GrB_eWiseMult_Vector_Semiring" href="#GraphBLASInterface.GrB_eWiseMult_Vector_Semiring"><code>GraphBLASInterface.GrB_eWiseMult_Vector_Semiring</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">GrB_eWiseMult_Vector_Semiring(w, mask, accum, semiring, u, v, desc)</code></pre><p>Compute element-wise vector multiplication using semiring. Semiring&#39;s multiply operator is used. <code>w&lt;mask&gt; = accum (w, u .* v)</code></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using GraphBLASInterface, SuiteSparseGraphBLAS

julia&gt; GrB_init(GrB_NONBLOCKING)
GrB_SUCCESS::GrB_Info = 0

julia&gt; u = GrB_Vector{Int64}()
GrB_Vector{Int64}

julia&gt; GrB_Vector_new(u, GrB_INT64, 5)
GrB_SUCCESS::GrB_Info = 0

julia&gt; I1 = ZeroBasedIndex[0, 2, 4]; X1 = [10, 20, 3]; n1 = 3;

julia&gt; GrB_Vector_build(u, I1, X1, n1, GrB_FIRST_INT64)
GrB_SUCCESS::GrB_Info = 0

julia&gt; v = GrB_Vector{Float64}()
GrB_Vector{Float64}

julia&gt; GrB_Vector_new(v, GrB_FP64, 5)
GrB_SUCCESS::GrB_Info = 0

julia&gt; I2 = ZeroBasedIndex[0, 1, 4]; X2 = [1.1, 2.2, 3.3]; n2 = 3;

julia&gt; GrB_Vector_build(v, I2, X2, n2, GrB_FIRST_FP64)
GrB_SUCCESS::GrB_Info = 0

julia&gt; w = GrB_Vector{Float64}()
GrB_Vector{Float64}

julia&gt; GrB_Vector_new(w, GrB_FP64, 5)
GrB_SUCCESS::GrB_Info = 0

julia&gt; GrB_eWiseMult_Vector_Semiring(w, GrB_NULL, GrB_NULL, GxB_PLUS_TIMES_FP64, u, v, GrB_NULL)
GrB_SUCCESS::GrB_Info = 0

julia&gt; @GxB_fprint(w, GxB_COMPLETE)

GraphBLAS vector: w 
nrows: 5 ncols: 1 max # entries: 2
format: standard CSC vlen: 5 nvec_nonempty: 1 nvec: 1 plen: 1 vdim: 1
hyper_ratio 0.0625
GraphBLAS type:  double size: 8
number of entries: 2 
column: 0 : 2 entries [0:1]
    row 0: double 11
    row 4: double 9.9</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/abhinavmehndiratta/GraphBLASInterface.jl/blob/5b1613f88ab6669d7f328ee1ba2f6ff68b3cafd6/src/operations/element_wise_multiplication.jl#L20-L76">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GraphBLASInterface.GrB_eWiseMult_Vector_Monoid" href="#GraphBLASInterface.GrB_eWiseMult_Vector_Monoid"><code>GraphBLASInterface.GrB_eWiseMult_Vector_Monoid</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">GrB_eWiseMult_Vector_Monoid(w, mask, accum, monoid, u, v, desc)</code></pre><p>Compute element-wise vector multiplication using monoid. <code>w&lt;mask&gt; = accum (w, u .* v)</code></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using GraphBLASInterface, SuiteSparseGraphBLAS

julia&gt; GrB_init(GrB_NONBLOCKING)
GrB_SUCCESS::GrB_Info = 0

julia&gt; u = GrB_Vector{Int64}()
GrB_Vector{Int64}

julia&gt; GrB_Vector_new(u, GrB_INT64, 5)
GrB_SUCCESS::GrB_Info = 0

julia&gt; I1 = ZeroBasedIndex[0, 2, 4]; X1 = [10, 20, 3]; n1 = 3;

julia&gt; GrB_Vector_build(u, I1, X1, n1, GrB_FIRST_INT64)
GrB_SUCCESS::GrB_Info = 0

julia&gt; v = GrB_Vector{Float64}()
GrB_Vector{Float64}

julia&gt; GrB_Vector_new(v, GrB_FP64, 5)
GrB_SUCCESS::GrB_Info = 0

julia&gt; I2 = ZeroBasedIndex[0, 1, 4]; X2 = [1.1, 2.2, 3.3]; n2 = 3;

julia&gt; GrB_Vector_build(v, I2, X2, n2, GrB_FIRST_FP64)
GrB_SUCCESS::GrB_Info = 0

julia&gt; w = GrB_Vector{Float64}()
GrB_Vector{Float64}

julia&gt; GrB_Vector_new(w, GrB_FP64, 5)
GrB_SUCCESS::GrB_Info = 0

julia&gt; GrB_eWiseMult_Vector_Monoid(w, GrB_NULL, GrB_NULL, GxB_MAX_FP64_MONOID, u, v, GrB_NULL)
GrB_SUCCESS::GrB_Info = 0

julia&gt; @GxB_fprint(w, GxB_COMPLETE)

GraphBLAS vector: w 
nrows: 5 ncols: 1 max # entries: 2
format: standard CSC vlen: 5 nvec_nonempty: 1 nvec: 1 plen: 1 vdim: 1
hyper_ratio 0.0625
GraphBLAS type:  double size: 8
number of entries: 2 
column: 0 : 2 entries [0:1]
    row 0: double 10
    row 4: double 3.3</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/abhinavmehndiratta/GraphBLASInterface.jl/blob/5b1613f88ab6669d7f328ee1ba2f6ff68b3cafd6/src/operations/element_wise_multiplication.jl#L87-L143">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GraphBLASInterface.GrB_eWiseMult_Vector_BinaryOp" href="#GraphBLASInterface.GrB_eWiseMult_Vector_BinaryOp"><code>GraphBLASInterface.GrB_eWiseMult_Vector_BinaryOp</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">GrB_eWiseMult_Vector_BinaryOp(w, mask, accum, mult, u, v, desc)</code></pre><p>Compute element-wise vector multiplication using binary operator. <code>w&lt;mask&gt; = accum (w, u .* v)</code></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using GraphBLASInterface, SuiteSparseGraphBLAS

julia&gt; GrB_init(GrB_NONBLOCKING)
GrB_SUCCESS::GrB_Info = 0

julia&gt; u = GrB_Vector{Int64}()
GrB_Vector{Int64}

julia&gt; GrB_Vector_new(u, GrB_INT64, 5)
GrB_SUCCESS::GrB_Info = 0

julia&gt; I1 = ZeroBasedIndex[0, 2, 4]; X1 = [10, 20, 30]; n1 = 3;

julia&gt; GrB_Vector_build(u, I1, X1, n1, GrB_FIRST_INT64)
GrB_SUCCESS::GrB_Info = 0

julia&gt; v = GrB_Vector{Float64}()
GrB_Vector{Float64}

julia&gt; GrB_Vector_new(v, GrB_FP64, 5)
GrB_SUCCESS::GrB_Info = 0

julia&gt; I2 = ZeroBasedIndex[0, 1, 4]; X2 = [1.1, 2.2, 3.3]; n2 = 3;

julia&gt; GrB_Vector_build(v, I2, X2, n2, GrB_FIRST_FP64)
GrB_SUCCESS::GrB_Info = 0

julia&gt; w = GrB_Vector{Float64}()
GrB_Vector{Float64}

julia&gt; GrB_Vector_new(w, GrB_FP64, 5)
GrB_SUCCESS::GrB_Info = 0

julia&gt; GrB_eWiseMult_Vector_BinaryOp(w, GrB_NULL, GrB_NULL, GrB_TIMES_FP64, u, v, GrB_NULL)
GrB_SUCCESS::GrB_Info = 0

julia&gt; @GxB_fprint(w, GxB_COMPLETE)

GraphBLAS vector: w 
nrows: 5 ncols: 1 max # entries: 2
format: standard CSC vlen: 5 nvec_nonempty: 1 nvec: 1 plen: 1 vdim: 1
hyper_ratio 0.0625
GraphBLAS type:  double size: 8
number of entries: 2 
column: 0 : 2 entries [0:1]
    row 0: double 11
    row 4: double 99</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/abhinavmehndiratta/GraphBLASInterface.jl/blob/5b1613f88ab6669d7f328ee1ba2f6ff68b3cafd6/src/operations/element_wise_multiplication.jl#L154-L210">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GraphBLASInterface.GrB_eWiseMult_Matrix_Semiring" href="#GraphBLASInterface.GrB_eWiseMult_Matrix_Semiring"><code>GraphBLASInterface.GrB_eWiseMult_Matrix_Semiring</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">GrB_eWiseMult_Matrix_Semiring(C, Mask, accum, semiring, A, B, desc)</code></pre><p>Compute element-wise matrix multiplication using semiring. Semiring&#39;s multiply operator is used. <code>C&lt;Mask&gt; = accum (C, A .* B)</code></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using GraphBLASInterface, SuiteSparseGraphBLAS

julia&gt; GrB_init(GrB_NONBLOCKING)
GrB_SUCCESS::GrB_Info = 0

julia&gt; A = GrB_Matrix{Int64}()
GrB_Matrix{Int64}

julia&gt; GrB_Matrix_new(A, GrB_INT64, 4, 4)
GrB_SUCCESS::GrB_Info = 0

julia&gt; I1 = ZeroBasedIndex[0, 0, 2, 2]; J1 = ZeroBasedIndex[1, 2, 0, 2]; X1 = [10, 20, 30, 40]; n1 = 4;

julia&gt; GrB_Matrix_build(A, I1, J1, X1, n1, GrB_FIRST_INT64)
GrB_SUCCESS::GrB_Info = 0

julia&gt; B = GrB_Matrix{Int64}()
GrB_Matrix{Int64}

julia&gt; GrB_Matrix_new(B, GrB_INT64, 4, 4)
GrB_SUCCESS::GrB_Info = 0

julia&gt; I2 = ZeroBasedIndex[0, 0, 2]; J2 = ZeroBasedIndex[3, 2, 0]; X2 = [15, 16, 17]; n2 = 3;

julia&gt; GrB_Matrix_build(B, I2, J2, X2, n2, GrB_FIRST_INT64)
GrB_SUCCESS::GrB_Info = 0

julia&gt; C = GrB_Matrix{Int64}()
GrB_Matrix{Int64}

julia&gt; GrB_Matrix_new(C, GrB_INT64, 4, 4)
GrB_SUCCESS::GrB_Info = 0

julia&gt; GrB_eWiseMult_Matrix_Semiring(C, GrB_NULL, GrB_NULL, GxB_PLUS_TIMES_INT64, A, B, GrB_NULL)
GrB_SUCCESS::GrB_Info = 0

julia&gt; @GxB_fprint(C, GxB_COMPLETE)

GraphBLAS matrix: C 
nrows: 4 ncols: 4 max # entries: 2
format: standard CSR vlen: 4 nvec_nonempty: 2 nvec: 4 plen: 4 vdim: 4
hyper_ratio 0.0625
GraphBLAS type:  int64_t size: 8
number of entries: 2 
row: 0 : 1 entries [0:0]
    column 2: int64 320
row: 2 : 1 entries [1:1]
    column 0: int64 510</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/abhinavmehndiratta/GraphBLASInterface.jl/blob/5b1613f88ab6669d7f328ee1ba2f6ff68b3cafd6/src/operations/element_wise_multiplication.jl#L221-L278">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GraphBLASInterface.GrB_eWiseMult_Matrix_Monoid" href="#GraphBLASInterface.GrB_eWiseMult_Matrix_Monoid"><code>GraphBLASInterface.GrB_eWiseMult_Matrix_Monoid</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">GrB_eWiseMult_Matrix_Monoid(C, Mask, accum, monoid, A, B, desc)</code></pre><p>Compute element-wise matrix multiplication using monoid. <code>C&lt;Mask&gt; = accum (C, A .* B)</code></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using GraphBLASInterface, SuiteSparseGraphBLAS

julia&gt; GrB_init(GrB_NONBLOCKING)
GrB_SUCCESS::GrB_Info = 0

julia&gt; A = GrB_Matrix{Int64}()
GrB_Matrix{Int64}

julia&gt; GrB_Matrix_new(A, GrB_INT64, 4, 4)
GrB_SUCCESS::GrB_Info = 0

julia&gt; I1 = ZeroBasedIndex[0, 0, 2, 2]; J1 = ZeroBasedIndex[1, 2, 0, 2]; X1 = [10, 20, 30, 40]; n1 = 4;

julia&gt; GrB_Matrix_build(A, I1, J1, X1, n1, GrB_FIRST_INT64)
GrB_SUCCESS::GrB_Info = 0

julia&gt; B = GrB_Matrix{Int64}()
GrB_Matrix{Int64}

julia&gt; GrB_Matrix_new(B, GrB_INT64, 4, 4)
GrB_SUCCESS::GrB_Info = 0

julia&gt; I2 = ZeroBasedIndex[0, 0, 2]; J2 = ZeroBasedIndex[3, 2, 0]; X2 = [15, 16, 17]; n2 = 3;

julia&gt; GrB_Matrix_build(B, I2, J2, X2, n2, GrB_FIRST_INT64)
GrB_SUCCESS::GrB_Info = 0

julia&gt; C = GrB_Matrix{Int64}()
GrB_Matrix{Int64}

julia&gt; GrB_Matrix_new(C, GrB_INT64, 4, 4)
GrB_SUCCESS::GrB_Info = 0

julia&gt; GrB_eWiseMult_Matrix_Monoid(C, GrB_NULL, GrB_NULL, GxB_PLUS_INT64_MONOID, A, B, GrB_NULL)
GrB_SUCCESS::GrB_Info = 0

julia&gt; @GxB_fprint(C, GxB_COMPLETE)

GraphBLAS matrix: C 
nrows: 4 ncols: 4 max # entries: 2
format: standard CSR vlen: 4 nvec_nonempty: 2 nvec: 4 plen: 4 vdim: 4
hyper_ratio 0.0625
GraphBLAS type:  int64_t size: 8
number of entries: 2 
row: 0 : 1 entries [0:0]
    column 2: int64 36
row: 2 : 1 entries [1:1]
    column 0: int64 47</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/abhinavmehndiratta/GraphBLASInterface.jl/blob/5b1613f88ab6669d7f328ee1ba2f6ff68b3cafd6/src/operations/element_wise_multiplication.jl#L289-L346">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GraphBLASInterface.GrB_eWiseMult_Matrix_BinaryOp" href="#GraphBLASInterface.GrB_eWiseMult_Matrix_BinaryOp"><code>GraphBLASInterface.GrB_eWiseMult_Matrix_BinaryOp</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">GrB_eWiseMult_Matrix_BinaryOp(C, Mask, accum, mult, A, B, desc)</code></pre><p>Compute element-wise matrix multiplication using binary operator. <code>C&lt;Mask&gt; = accum (C, A .* B)</code></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using GraphBLASInterface, SuiteSparseGraphBLAS

julia&gt; GrB_init(GrB_NONBLOCKING)
GrB_SUCCESS::GrB_Info = 0

julia&gt; A = GrB_Matrix{Int64}()
GrB_Matrix{Int64}

julia&gt; GrB_Matrix_new(A, GrB_INT64, 4, 4)
GrB_SUCCESS::GrB_Info = 0

julia&gt; I1 = ZeroBasedIndex[0, 0, 2, 2]; J1 = ZeroBasedIndex[1, 2, 0, 2]; X1 = [10, 20, 30, 40]; n1 = 4;

julia&gt; GrB_Matrix_build(A, I1, J1, X1, n1, GrB_FIRST_INT64)
GrB_SUCCESS::GrB_Info = 0

julia&gt; B = GrB_Matrix{Int64}()
GrB_Matrix{Int64}

julia&gt; GrB_Matrix_new(B, GrB_INT64, 4, 4)
GrB_SUCCESS::GrB_Info = 0

julia&gt; I2 = ZeroBasedIndex[0, 0, 2]; J2 = ZeroBasedIndex[3, 2, 0]; X2 = [15, 16, 17]; n2 = 3;

julia&gt; GrB_Matrix_build(B, I2, J2, X2, n2, GrB_FIRST_INT64)
GrB_SUCCESS::GrB_Info = 0

julia&gt; C = GrB_Matrix{Int64}()
GrB_Matrix{Int64}

julia&gt; GrB_Matrix_new(C, GrB_INT64, 4, 4)
GrB_SUCCESS::GrB_Info = 0

julia&gt; GrB_eWiseMult_Matrix_BinaryOp(C, GrB_NULL, GrB_NULL, GrB_PLUS_INT64, A, B, GrB_NULL)
GrB_SUCCESS::GrB_Info = 0

julia&gt; @GxB_fprint(C, GxB_COMPLETE)

GraphBLAS matrix: C 
nrows: 4 ncols: 4 max # entries: 2
format: standard CSR vlen: 4 nvec_nonempty: 2 nvec: 4 plen: 4 vdim: 4
hyper_ratio 0.0625
GraphBLAS type:  int64_t size: 8
number of entries: 2 
row: 0 : 1 entries [0:0]
    column 2: int64 36
row: 2 : 1 entries [1:1]
    column 0: int64 47</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/abhinavmehndiratta/GraphBLASInterface.jl/blob/5b1613f88ab6669d7f328ee1ba2f6ff68b3cafd6/src/operations/element_wise_multiplication.jl#L357-L414">source</a></section><h2><a class="nav-anchor" id="Element-wise-addition-1" href="#Element-wise-addition-1">Element-wise addition</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GraphBLASInterface.GrB_eWiseAdd" href="#GraphBLASInterface.GrB_eWiseAdd"><code>GraphBLASInterface.GrB_eWiseAdd</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">GrB_eWiseAdd(C, mask, accum, op, A, B, desc)</code></pre><p>Generic method for element-wise matrix and vector operations: using set union.</p><p><code>GrB_eWiseAdd</code> computes <code>C&lt;Mask&gt; = accum (C, A + B)</code>, where pairs of elements in two matrices (or two vectors) are pairwise &quot;added&quot;. The &quot;add&quot; operator can be any binary operator. With the plus operator, this is the same matrix addition in conventional linear algebra. The pattern of the result T = A + B is the set union of A and B. Entries outside of the union are not computed. That is, if both A(i, j) and B(i, j) are present in the pattern of A and B, then T(i, j) = A(i, j) &quot;+&quot; B(i, j). If only A(i, j) is present then T(i, j) = A (i, j) and the &quot;+&quot; operator is not used. Likewise, if only B(i, j) is in the pattern of B but A(i, j) is not in the pattern of A, then T(i, j) = B(i, j). For a semiring, the mult operator is the semiring&#39;s add operator.</p></div></div><a class="source-link" target="_blank" href="https://github.com/abhinavmehndiratta/GraphBLASInterface.jl/blob/5b1613f88ab6669d7f328ee1ba2f6ff68b3cafd6/src/operations/element_wise_addition.jl#L1-L14">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GraphBLASInterface.GrB_eWiseAdd_Vector_Semiring" href="#GraphBLASInterface.GrB_eWiseAdd_Vector_Semiring"><code>GraphBLASInterface.GrB_eWiseAdd_Vector_Semiring</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">GrB_eWiseAdd_Vector_Semiring(w, mask, accum, semiring, u, v, desc)</code></pre><p>Compute element-wise vector addition using semiring. Semiring&#39;s add operator is used. <code>w&lt;mask&gt; = accum (w, u + v)</code></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using GraphBLASInterface, SuiteSparseGraphBLAS

julia&gt; GrB_init(GrB_NONBLOCKING)
GrB_SUCCESS::GrB_Info = 0

julia&gt; u = GrB_Vector{Int64}()
GrB_Vector{Int64}

julia&gt; GrB_Vector_new(u, GrB_INT64, 5)
GrB_SUCCESS::GrB_Info = 0

julia&gt; I1 = ZeroBasedIndex[0, 2, 4]; X1 = [10, 20, 3]; n1 = 3;

julia&gt; GrB_Vector_build(u, I1, X1, n1, GrB_FIRST_INT64)
GrB_SUCCESS::GrB_Info = 0

julia&gt; v = GrB_Vector{Float64}()
GrB_Vector{Float64}

julia&gt; GrB_Vector_new(v, GrB_FP64, 5)
GrB_SUCCESS::GrB_Info = 0

julia&gt; I2 = ZeroBasedIndex[0, 1, 4]; X2 = [1.1, 2.2, 3.3]; n2 = 3;

julia&gt; GrB_Vector_build(v, I2, X2, n2, GrB_FIRST_FP64)
GrB_SUCCESS::GrB_Info = 0

julia&gt; w = GrB_Vector{Float64}()
GrB_Vector{Float64}

julia&gt; GrB_Vector_new(w, GrB_FP64, 5)
GrB_SUCCESS::GrB_Info = 0

julia&gt; GrB_eWiseAdd_Vector_Semiring(w, GrB_NULL, GrB_NULL, GxB_PLUS_TIMES_FP64, u, v, GrB_NULL)
GrB_SUCCESS::GrB_Info = 0

julia&gt; @GxB_fprint(w, GxB_COMPLETE)

GraphBLAS vector: w 
nrows: 5 ncols: 1 max # entries: 4
format: standard CSC vlen: 5 nvec_nonempty: 1 nvec: 1 plen: 1 vdim: 1
hyper_ratio 0.0625
GraphBLAS type:  double size: 8
number of entries: 4 
column: 0 : 4 entries [0:3]
    row 0: double 11.1
    row 1: double 2.2
    row 2: double 20
    row 4: double 6.3</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/abhinavmehndiratta/GraphBLASInterface.jl/blob/5b1613f88ab6669d7f328ee1ba2f6ff68b3cafd6/src/operations/element_wise_addition.jl#L22-L80">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GraphBLASInterface.GrB_eWiseAdd_Vector_Monoid" href="#GraphBLASInterface.GrB_eWiseAdd_Vector_Monoid"><code>GraphBLASInterface.GrB_eWiseAdd_Vector_Monoid</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">GrB_eWiseAdd_Vector_Monoid(w, mask, accum, monoid, u, v, desc)</code></pre><p>Compute element-wise vector addition using monoid. <code>w&lt;mask&gt; = accum (w, u + v)</code></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using GraphBLASInterface, SuiteSparseGraphBLAS

julia&gt; GrB_init(GrB_NONBLOCKING)
GrB_SUCCESS::GrB_Info = 0

julia&gt; u = GrB_Vector{Int64}()
GrB_Vector{Int64}

julia&gt; GrB_Vector_new(u, GrB_INT64, 5)
GrB_SUCCESS::GrB_Info = 0

julia&gt; I1 = ZeroBasedIndex[0, 2, 4]; X1 = [10, 20, 3]; n1 = 3;

julia&gt; GrB_Vector_build(u, I1, X1, n1, GrB_FIRST_INT64)
GrB_SUCCESS::GrB_Info = 0

julia&gt; v = GrB_Vector{Float64}()
GrB_Vector{Float64}

julia&gt; GrB_Vector_new(v, GrB_FP64, 5)
GrB_SUCCESS::GrB_Info = 0

julia&gt; I2 = ZeroBasedIndex[0, 1, 4]; X2 = [1.1, 2.2, 3.3]; n2 = 3;

julia&gt; GrB_Vector_build(v, I2, X2, n2, GrB_FIRST_FP64)
GrB_SUCCESS::GrB_Info = 0

julia&gt; w = GrB_Vector{Float64}()
GrB_Vector{Float64}

julia&gt; GrB_Vector_new(w, GrB_FP64, 5)
GrB_SUCCESS::GrB_Info = 0

julia&gt; GrB_eWiseAdd_Vector_Monoid(w, GrB_NULL, GrB_NULL, GxB_MAX_FP64_MONOID, u, v, GrB_NULL)
GrB_SUCCESS::GrB_Info = 0

julia&gt; @GxB_fprint(w, GxB_COMPLETE)

GraphBLAS vector: w 
nrows: 5 ncols: 1 max # entries: 4
format: standard CSC vlen: 5 nvec_nonempty: 1 nvec: 1 plen: 1 vdim: 1
hyper_ratio 0.0625
GraphBLAS type:  double size: 8
number of entries: 4 
column: 0 : 4 entries [0:3]
    row 0: double 10
    row 1: double 2.2
    row 2: double 20
    row 4: double 3.3</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/abhinavmehndiratta/GraphBLASInterface.jl/blob/5b1613f88ab6669d7f328ee1ba2f6ff68b3cafd6/src/operations/element_wise_addition.jl#L91-L149">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GraphBLASInterface.GrB_eWiseAdd_Vector_BinaryOp" href="#GraphBLASInterface.GrB_eWiseAdd_Vector_BinaryOp"><code>GraphBLASInterface.GrB_eWiseAdd_Vector_BinaryOp</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">GrB_eWiseAdd_Vector_BinaryOp(w, mask, accum, add, u, v, desc)</code></pre><p>Compute element-wise vector addition using binary operator. <code>w&lt;mask&gt; = accum (w, u + v)</code></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using GraphBLASInterface, SuiteSparseGraphBLAS

julia&gt; GrB_init(GrB_NONBLOCKING)
GrB_SUCCESS::GrB_Info = 0

julia&gt; u = GrB_Vector{Int64}()
GrB_Vector{Int64}

julia&gt; GrB_Vector_new(u, GrB_INT64, 5)
GrB_SUCCESS::GrB_Info = 0

julia&gt; I1 = ZeroBasedIndex[0, 2, 4]; X1 = [10, 20, 3]; n1 = 3;

julia&gt; GrB_Vector_build(u, I1, X1, n1, GrB_FIRST_INT64)
GrB_SUCCESS::GrB_Info = 0

julia&gt; v = GrB_Vector{Float64}()
GrB_Vector{Float64}

julia&gt; GrB_Vector_new(v, GrB_FP64, 5)
GrB_SUCCESS::GrB_Info = 0

julia&gt; I2 = ZeroBasedIndex[0, 1, 4]; X2 = [1.1, 2.2, 3.3]; n2 = 3;

julia&gt; GrB_Vector_build(v, I2, X2, n2, GrB_FIRST_FP64)
GrB_SUCCESS::GrB_Info = 0

julia&gt; w = GrB_Vector{Float64}()
GrB_Vector{Float64}

julia&gt; GrB_Vector_new(w, GrB_FP64, 5)
GrB_SUCCESS::GrB_Info = 0

julia&gt; GrB_eWiseAdd_Vector_BinaryOp(w, GrB_NULL, GrB_NULL, GrB_PLUS_FP64, u, v, GrB_NULL)
GrB_SUCCESS::GrB_Info = 0

julia&gt; @GxB_fprint(w, GxB_COMPLETE)

GraphBLAS vector: w 
nrows: 5 ncols: 1 max # entries: 4
format: standard CSC vlen: 5 nvec_nonempty: 1 nvec: 1 plen: 1 vdim: 1
hyper_ratio 0.0625
GraphBLAS type:  double size: 8
number of entries: 4 
column: 0 : 4 entries [0:3]
    row 0: double 11.1
    row 1: double 2.2
    row 2: double 20
    row 4: double 6.3</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/abhinavmehndiratta/GraphBLASInterface.jl/blob/5b1613f88ab6669d7f328ee1ba2f6ff68b3cafd6/src/operations/element_wise_addition.jl#L160-L218">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GraphBLASInterface.GrB_eWiseAdd_Matrix_Semiring" href="#GraphBLASInterface.GrB_eWiseAdd_Matrix_Semiring"><code>GraphBLASInterface.GrB_eWiseAdd_Matrix_Semiring</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">GrB_eWiseAdd_Matrix_Semiring(C, Mask, accum, semiring, A, B, desc)</code></pre><p>Compute element-wise matrix addition using semiring. Semiring&#39;s add operator is used. <code>C&lt;Mask&gt; = accum (C, A + B)</code></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using GraphBLASInterface, SuiteSparseGraphBLAS

julia&gt; GrB_init(GrB_NONBLOCKING)
GrB_SUCCESS::GrB_Info = 0

julia&gt; A = GrB_Matrix{Int64}()
GrB_Matrix{Int64}

julia&gt; GrB_Matrix_new(A, GrB_INT64, 4, 4)
GrB_SUCCESS::GrB_Info = 0

julia&gt; I1 = ZeroBasedIndex[0, 0, 2, 2]; J1 = ZeroBasedIndex[1, 2, 0, 2]; X1 = [10, 20, 30, 40]; n1 = 4;

julia&gt; GrB_Matrix_build(A, I1, J1, X1, n1, GrB_FIRST_INT64)
GrB_SUCCESS::GrB_Info = 0

julia&gt; B = GrB_Matrix{Int64}()
GrB_Matrix{Int64}

julia&gt; GrB_Matrix_new(B, GrB_INT64, 4, 4)
GrB_SUCCESS::GrB_Info = 0

julia&gt; I2 = ZeroBasedIndex[0, 0, 2]; J2 = ZeroBasedIndex[3, 2, 0]; X2 = [15, 16, 17]; n2 = 3;

julia&gt; GrB_Matrix_build(B, I2, J2, X2, n2, GrB_FIRST_INT64)
GrB_SUCCESS::GrB_Info = 0

julia&gt; C = GrB_Matrix{Int64}()
GrB_Matrix{Int64}

julia&gt; GrB_Matrix_new(C, GrB_INT64, 4, 4)
GrB_SUCCESS::GrB_Info = 0

julia&gt; GrB_eWiseAdd_Matrix_Semiring(C, GrB_NULL, GrB_NULL, GxB_PLUS_TIMES_INT64, A, B, GrB_NULL)
GrB_SUCCESS::GrB_Info = 0

julia&gt; @GxB_fprint(C, GxB_COMPLETE)

GraphBLAS matrix: C 
nrows: 4 ncols: 4 max # entries: 5
format: standard CSR vlen: 4 nvec_nonempty: 2 nvec: 4 plen: 4 vdim: 4
hyper_ratio 0.0625
GraphBLAS type:  int64_t size: 8
number of entries: 5 
row: 0 : 3 entries [0:2]
    column 1: int64 10
    column 2: int64 36
    column 3: int64 15
row: 2 : 2 entries [3:4]
    column 0: int64 47
    column 2: int64 40</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/abhinavmehndiratta/GraphBLASInterface.jl/blob/5b1613f88ab6669d7f328ee1ba2f6ff68b3cafd6/src/operations/element_wise_addition.jl#L229-L289">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GraphBLASInterface.GrB_eWiseAdd_Matrix_Monoid" href="#GraphBLASInterface.GrB_eWiseAdd_Matrix_Monoid"><code>GraphBLASInterface.GrB_eWiseAdd_Matrix_Monoid</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">GrB_eWiseAdd_Matrix_Monoid(C, Mask, accum, monoid, A, B, desc)</code></pre><p>Compute element-wise matrix addition using monoid. <code>C&lt;Mask&gt; = accum (C, A + B)</code></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using GraphBLASInterface, SuiteSparseGraphBLAS

julia&gt; GrB_init(GrB_NONBLOCKING)
GrB_SUCCESS::GrB_Info = 0

julia&gt; A = GrB_Matrix{Int64}()
GrB_Matrix{Int64}

julia&gt; GrB_Matrix_new(A, GrB_INT64, 4, 4)
GrB_SUCCESS::GrB_Info = 0

julia&gt; I1 = ZeroBasedIndex[0, 0, 2, 2]; J1 = ZeroBasedIndex[1, 2, 0, 2]; X1 = [10, 20, 30, 40]; n1 = 4;

julia&gt; GrB_Matrix_build(A, I1, J1, X1, n1, GrB_FIRST_INT64)
GrB_SUCCESS::GrB_Info = 0

julia&gt; B = GrB_Matrix{Int64}()
GrB_Matrix{Int64}

julia&gt; GrB_Matrix_new(B, GrB_INT64, 4, 4)
GrB_SUCCESS::GrB_Info = 0

julia&gt; I2 = ZeroBasedIndex[0, 0, 2]; J2 = ZeroBasedIndex[3, 2, 0]; X2 = [15, 16, 17]; n2 = 3;

julia&gt; GrB_Matrix_build(B, I2, J2, X2, n2, GrB_FIRST_INT64)
GrB_SUCCESS::GrB_Info = 0

julia&gt; C = GrB_Matrix{Int64}()
GrB_Matrix{Int64}

julia&gt; GrB_Matrix_new(C, GrB_INT64, 4, 4)
GrB_SUCCESS::GrB_Info = 0

julia&gt; mask = GrB_Matrix{Bool}()
GrB_Matrix{Bool}

julia&gt; GrB_Matrix_new(mask, GrB_BOOL, 4, 4)
GrB_SUCCESS::GrB_Info = 0

julia&gt; GrB_Matrix_build(mask, ZeroBasedIndex[0, 0], ZeroBasedIndex[1, 2], [true, true], 2, GrB_FIRST_BOOL)
GrB_SUCCESS::GrB_Info = 0

julia&gt; GrB_eWiseAdd_Matrix_Monoid(C, mask, GrB_NULL, GxB_PLUS_INT64_MONOID, A, B, GrB_NULL)
GrB_SUCCESS::GrB_Info = 0

julia&gt; @GxB_fprint(C, GxB_COMPLETE)

GraphBLAS matrix: C 
nrows: 4 ncols: 4 max # entries: 5
format: standard CSR vlen: 4 nvec_nonempty: 1 nvec: 4 plen: 4 vdim: 4
hyper_ratio 0.0625
GraphBLAS type:  int64_t size: 8
number of entries: 2 
row: 0 : 2 entries [0:1]
    column 1: int64 10
    column 2: int64 36</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/abhinavmehndiratta/GraphBLASInterface.jl/blob/5b1613f88ab6669d7f328ee1ba2f6ff68b3cafd6/src/operations/element_wise_addition.jl#L300-L365">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GraphBLASInterface.GrB_eWiseAdd_Matrix_BinaryOp" href="#GraphBLASInterface.GrB_eWiseAdd_Matrix_BinaryOp"><code>GraphBLASInterface.GrB_eWiseAdd_Matrix_BinaryOp</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">GrB_eWiseAdd_Matrix_BinaryOp(C, Mask, accum, add, A, B, desc)</code></pre><p>Compute element-wise matrix addition using binary operator. <code>C&lt;Mask&gt; = accum (C, A + B)</code></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using GraphBLASInterface, SuiteSparseGraphBLAS

julia&gt; GrB_init(GrB_NONBLOCKING)
GrB_SUCCESS::GrB_Info = 0

julia&gt; A = GrB_Matrix{Int64}()
GrB_Matrix{Int64}

julia&gt; GrB_Matrix_new(A, GrB_INT64, 4, 4)
GrB_SUCCESS::GrB_Info = 0

julia&gt; I1 = ZeroBasedIndex[0, 0, 2, 2]; J1 = ZeroBasedIndex[1, 2, 0, 2]; X1 = [10, 20, 30, 40]; n1 = 4;

julia&gt; GrB_Matrix_build(A, I1, J1, X1, n1, GrB_FIRST_INT64)
GrB_SUCCESS::GrB_Info = 0

julia&gt; B = GrB_Matrix{Int64}()
GrB_Matrix{Int64}

julia&gt; GrB_Matrix_new(B, GrB_INT64, 4, 4)
GrB_SUCCESS::GrB_Info = 0

julia&gt; I2 = [0, 0, 2]; J2 = [3, 2, 0]; X2 = [15, 16, 17]; n2 = 3;

julia&gt; GrB_Matrix_build(B, I2, J2, X2, n2, GrB_FIRST_INT64)
GrB_SUCCESS::GrB_Info = 0

julia&gt; C = GrB_Matrix{Int64}()
GrB_Matrix{Int64}

julia&gt; GrB_Matrix_new(C, GrB_INT64, 4, 4)
GrB_SUCCESS::GrB_Info = 0

julia&gt; GrB_eWiseAdd_Matrix_BinaryOp(C, GrB_NULL, GrB_NULL, GrB_PLUS_INT64, A, B, GrB_NULL)
GrB_SUCCESS::GrB_Info = 0

julia&gt; GrB_Matrix_extractTuples(C)
julia&gt; @GxB_fprint(C, GxB_COMPLETE)

GraphBLAS matrix: C 
nrows: 4 ncols: 4 max # entries: 5
format: standard CSR vlen: 4 nvec_nonempty: 2 nvec: 4 plen: 4 vdim: 4
hyper_ratio 0.0625
GraphBLAS type:  int64_t size: 8
number of entries: 5 
row: 0 : 3 entries [0:2]
    column 1: int64 10
    column 2: int64 36
    column 3: int64 15
row: 2 : 2 entries [3:4]
    column 0: int64 47
    column 2: int64 40</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/abhinavmehndiratta/GraphBLASInterface.jl/blob/5b1613f88ab6669d7f328ee1ba2f6ff68b3cafd6/src/operations/element_wise_addition.jl#L376-L437">source</a></section><h2><a class="nav-anchor" id="Extract-1" href="#Extract-1">Extract</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GraphBLASInterface.GrB_extract" href="#GraphBLASInterface.GrB_extract"><code>GraphBLASInterface.GrB_extract</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">GrB_extract(arg1, Mask, accum, arg4, ...)</code></pre><p>Generic matrix/vector extraction.</p></div></div><a class="source-link" target="_blank" href="https://github.com/abhinavmehndiratta/GraphBLASInterface.jl/blob/5b1613f88ab6669d7f328ee1ba2f6ff68b3cafd6/src/operations/extract.jl#L1-L5">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GraphBLASInterface.GrB_Vector_extract" href="#GraphBLASInterface.GrB_Vector_extract"><code>GraphBLASInterface.GrB_Vector_extract</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">GrB_Vector_extract(w, mask, accum, u, I, ni, desc)</code></pre><p>Extract a sub-vector from a larger vector as specified by a set of indices. The result is a vector whose size is equal to the number of indices.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using GraphBLASInterface, SuiteSparseGraphBLAS

julia&gt; GrB_init(GrB_NONBLOCKING)
GrB_SUCCESS::GrB_Info = 0

julia&gt; V = GrB_Vector{Int64}()
GrB_Vector{Int64}

julia&gt; GrB_Vector_new(V, GrB_INT64, 5)
GrB_SUCCESS::GrB_Info = 0

julia&gt; I = ZeroBasedIndex[1, 2, 4]; X = [15, 32, 84]; n = 3;

julia&gt; GrB_Vector_build(V, I, X, n, GrB_FIRST_INT64)
GrB_SUCCESS::GrB_Info = 0

julia&gt; @GxB_Vector_fprint(V, GxB_COMPLETE)

GraphBLAS vector: V
nrows: 5 ncols: 1 max # entries: 3
format: standard CSC vlen: 5 nvec_nonempty: 1 nvec: 1 plen: 1 vdim: 1
hyper_ratio 0.0625
GraphBLAS type:  int64_t size: 8
number of entries: 3
column: 0 : 3 entries [0:2]
    row 1: int64 15
    row 2: int64 32
    row 4: int64 84


julia&gt; W = GrB_Vector{Int64}()
GrB_Vector{Int64}

julia&gt; GrB_Vector_new(W, GrB_INT64, 2)
GrB_SUCCESS::GrB_Info = 0

julia&gt; GrB_Vector_extract(W, GrB_NULL, GrB_NULL, V, ZeroBasedIndex[1, 4], 2, GrB_NULL)
GrB_SUCCESS::GrB_Info = 0

julia&gt; GrB_Vector_extractTuples(W)[2]
2-element Array{Int64,1}:
 15
 84</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/abhinavmehndiratta/GraphBLASInterface.jl/blob/5b1613f88ab6669d7f328ee1ba2f6ff68b3cafd6/src/operations/extract.jl#L10-L62">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GraphBLASInterface.GrB_Matrix_extract" href="#GraphBLASInterface.GrB_Matrix_extract"><code>GraphBLASInterface.GrB_Matrix_extract</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">GrB_Matrix_extract(C, Mask, accum, A, I, ni, J, nj, desc)</code></pre><p>Extract a sub-matrix from a larger matrix as specified by a set of row indices and a set of column indices. The result is a matrix whose size is equal to size of the sets of indices.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using GraphBLASInterface, SuiteSparseGraphBLAS

julia&gt; GrB_init(GrB_NONBLOCKING)
GrB_SUCCESS::GrB_Info = 0

julia&gt; MAT = GrB_Matrix{Int8}()
GrB_Matrix{Int8}

julia&gt; GrB_Matrix_new(MAT, GrB_INT8, 4, 4)
GrB_SUCCESS::GrB_Info = 0

julia&gt; I = ZeroBasedIndex[1, 2, 2, 2, 3]; J = ZeroBasedIndex[1, 2, 1, 3, 3]; X = Int8[2, 3, 4, 5, 6]; n = 5;

julia&gt; GrB_Matrix_build(MAT, I, J, X, n, GrB_FIRST_INT8)
GrB_SUCCESS::GrB_Info = 0

julia&gt; @GxB_Matrix_fprint(MAT, GxB_COMPLETE)

GraphBLAS matrix: MAT
nrows: 4 ncols: 4 max # entries: 5
format: standard CSR vlen: 4 nvec_nonempty: 3 nvec: 4 plen: 4 vdim: 4
hyper_ratio 0.0625
GraphBLAS type:  int8_t size: 1
number of entries: 5
row: 1 : 1 entries [0:0]
    column 1: int8 2
row: 2 : 3 entries [1:3]
    column 1: int8 4
    column 2: int8 3
    column 3: int8 5
row: 3 : 1 entries [4:4]
    column 3: int8 6


julia&gt; OUT = GrB_Matrix{Int8}()
GrB_Matrix{Int8}

julia&gt; GrB_Matrix_new(OUT, GrB_INT8, 2, 2)
GrB_SUCCESS::GrB_Info = 0

julia&gt; GrB_Matrix_extract(OUT, GrB_NULL, GrB_NULL, MAT, ZeroBasedIndex[1, 3], 2, ZeroBasedIndex[1, 3], 2, GrB_NULL)
GrB_SUCCESS::GrB_Info = 0

julia&gt; GrB_Matrix_extractTuples(OUT)[3]
2-element Array{Int8,1}:
 2
 6</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/abhinavmehndiratta/GraphBLASInterface.jl/blob/5b1613f88ab6669d7f328ee1ba2f6ff68b3cafd6/src/operations/extract.jl#L73-L129">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GraphBLASInterface.GrB_Col_extract" href="#GraphBLASInterface.GrB_Col_extract"><code>GraphBLASInterface.GrB_Col_extract</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">GrB_Col_extract(w, mask, accum, A, I, ni, j, desc)</code></pre><p>Extract from one column of a matrix into a vector. With the transpose descriptor for the source matrix, elements of an arbitrary row of the matrix can be extracted with this function as well.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using GraphBLASInterface, SuiteSparseGraphBLAS

julia&gt; GrB_init(GrB_NONBLOCKING)
GrB_SUCCESS::GrB_Info = 0

julia&gt; MAT = GrB_Matrix{Int8}()
GrB_Matrix{Int8}

julia&gt; GrB_Matrix_new(MAT, GrB_INT8, 4, 4)
GrB_SUCCESS::GrB_Info = 0

julia&gt; I = ZeroBasedIndex[1, 2, 2, 2, 3]; J = ZeroBasedIndex[1, 2, 1, 3, 3]; X = Int8[23, 34, 43, 57, 61]; n = 5;

julia&gt; GrB_Matrix_build(MAT, I, J, X, n, GrB_FIRST_INT8)
GrB_SUCCESS::GrB_Info = 0

julia&gt; @GxB_Matrix_fprint(MAT, GxB_COMPLETE)

GraphBLAS matrix: MAT
nrows: 4 ncols: 4 max # entries: 5
format: standard CSR vlen: 4 nvec_nonempty: 3 nvec: 4 plen: 4 vdim: 4
hyper_ratio 0.0625
GraphBLAS type:  int8_t size: 1
number of entries: 5
row: 1 : 1 entries [0:0]
    column 1: int8 23
row: 2 : 3 entries [1:3]
    column 1: int8 43
    column 2: int8 34
    column 3: int8 57
row: 3 : 1 entries [4:4]
    column 3: int8 61


julia&gt; desc = GrB_Descriptor()
GrB_Descriptor

julia&gt; GrB_Descriptor_new(desc)
GrB_SUCCESS::GrB_Info = 0

julia&gt; GrB_Descriptor_set(desc, GrB_INP0, GrB_TRAN) # descriptor to transpose first input
GrB_SUCCESS::GrB_Info = 0

julia&gt; out = GrB_Vector{Int8}()
GrB_Vector{Int8}

julia&gt; GrB_Vector_new(out, GrB_INT8, 3)
GrB_SUCCESS::GrB_Info = 0

julia&gt; GrB_Col_extract(out, GrB_NULL, GrB_NULL, MAT, ZeroBasedIndex[1, 2, 3], 3, ZeroBasedIndex(2), desc) # extract elements of row 2
GrB_SUCCESS::GrB_Info = 0

julia&gt; GrB_Vector_extractTuples(out)[2]
3-element Array{Int8,1}:
 43
 34
 57</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/abhinavmehndiratta/GraphBLASInterface.jl/blob/5b1613f88ab6669d7f328ee1ba2f6ff68b3cafd6/src/operations/extract.jl#L142-L208">source</a></section><h2><a class="nav-anchor" id="Assign-1" href="#Assign-1">Assign</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GraphBLASInterface.GrB_assign" href="#GraphBLASInterface.GrB_assign"><code>GraphBLASInterface.GrB_assign</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">GrB_assign(arg1, Mask, accum, arg4, arg5, ...)</code></pre><p>Generic method for submatrix/subvector assignment.</p></div></div><a class="source-link" target="_blank" href="https://github.com/abhinavmehndiratta/GraphBLASInterface.jl/blob/5b1613f88ab6669d7f328ee1ba2f6ff68b3cafd6/src/operations/assign.jl#L1-L5">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GraphBLASInterface.GrB_Vector_assign" href="#GraphBLASInterface.GrB_Vector_assign"><code>GraphBLASInterface.GrB_Vector_assign</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">GrB_Vector_assign(w, mask, accum, u, I, ni, desc)</code></pre><p>Assign values from one GraphBLAS vector to a subset of a vector as specified by a set of indices. The size of the input vector is the same size as the index array provided.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using GraphBLASInterface, SuiteSparseGraphBLAS

julia&gt; GrB_init(GrB_NONBLOCKING)
GrB_SUCCESS::GrB_Info = 0

julia&gt; w = GrB_Vector{Int64}()
GrB_Vector{Int64}

julia&gt; GrB_Vector_new(w, GrB_INT64, 5)
GrB_SUCCESS::GrB_Info = 0

julia&gt; u = GrB_Vector{Int64}()
GrB_Vector{Int64}

julia&gt; GrB_Vector_new(u, GrB_INT64, 2)
GrB_SUCCESS::GrB_Info = 0

julia&gt; I = ZeroBasedIndex[0, 1]; X = [10, 20]; n = 2;

julia&gt; GrB_Vector_build(u, I, X, n, GrB_FIRST_INT64)
GrB_SUCCESS::GrB_Info = 0

julia&gt; GrB_Vector_assign(w, GrB_NULL, GrB_NULL, u, [2, 4], 2, GrB_NULL)
GrB_SUCCESS::GrB_Info = 0

julia&gt; GrB_Vector_extractTuples(w)
(ZeroBasedIndex[ZeroBasedIndex(0x0000000000000002), ZeroBasedIndex(0x0000000000000004)], [10, 20])</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/abhinavmehndiratta/GraphBLASInterface.jl/blob/5b1613f88ab6669d7f328ee1ba2f6ff68b3cafd6/src/operations/assign.jl#L13-L49">source</a><div><div><pre><code class="language-none">GrB_Vector_assign(w, mask, accum, x, I, ni, desc)</code></pre><p>Assign the same value to a specified subset of vector elements. With the use of <code>GrB_ALL</code>, the entire destination vector can be filled with the constant.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using GraphBLASInterface, SuiteSparseGraphBLAS

julia&gt; GrB_init(GrB_NONBLOCKING)
GrB_SUCCESS::GrB_Info = 0

julia&gt; w = GrB_Vector{Float64}()
GrB_Vector{Float64}

julia&gt; GrB_Vector_new(w, GrB_FP64, 4)
GrB_SUCCESS::GrB_Info = 0

julia&gt; GrB_Vector_assign(w, GrB_NULL, GrB_NULL, 2.3, ZeroBasedIndex[0, 3], 2, GrB_NULL)
GrB_SUCCESS::GrB_Info = 0

julia&gt; GrB_Vector_extractTuples(w)
(ZeroBasedIndex[ZeroBasedIndex(0x0000000000000000), ZeroBasedIndex(0x0000000000000003)], [2.3, 2.3])</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/abhinavmehndiratta/GraphBLASInterface.jl/blob/5b1613f88ab6669d7f328ee1ba2f6ff68b3cafd6/src/operations/assign.jl#L265-L290">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GraphBLASInterface.GrB_Matrix_assign" href="#GraphBLASInterface.GrB_Matrix_assign"><code>GraphBLASInterface.GrB_Matrix_assign</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">GrB_Matrix_assign(C, Mask, accum, A, I, ni, J, nj, desc)</code></pre><p>Assign values from one GraphBLAS matrix to a subset of a matrix as specified by a set of indices. The dimensions of the input matrix are the same size as the row and column index arrays provided.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using GraphBLASInterface, SuiteSparseGraphBLAS

julia&gt; GrB_init(GrB_NONBLOCKING)
GrB_SUCCESS::GrB_Info = 0

julia&gt; A = GrB_Matrix{Int64}()
GrB_Matrix{Int64}

julia&gt; GrB_Matrix_new(A, GrB_INT64, 4, 4)
GrB_SUCCESS::GrB_Info = 0

julia&gt; I = ZeroBasedIndex[0, 0, 2, 2]; J = ZeroBasedIndex[1, 2, 0, 2]; X = [10, 20, 30, 40]; n = 4;

julia&gt; GrB_Matrix_build(A, I, J, X, n, GrB_FIRST_INT64)
GrB_SUCCESS::GrB_Info = 0

julia&gt; C = GrB_Matrix{Int64}()
GrB_Matrix{Int64}

julia&gt; GrB_Matrix_new(C, GrB_INT64, 4, 4)
GrB_SUCCESS::GrB_Info = 0

julia&gt; GrB_Matrix_assign(C, GrB_NULL, GrB_NULL, A, GrB_ALL, 4, GrB_ALL, 4, GrB_NULL)
GrB_SUCCESS::GrB_Info = 0

julia&gt; GrB_wait()
GrB_SUCCESS::GrB_Info = 0

julia&gt; @GxB_Matrix_fprint(C, GxB_COMPLETE)

GraphBLAS matrix: C
nrows: 4 ncols: 4 max # entries: 4
format: standard CSR vlen: 4 nvec_nonempty: 2 nvec: 4 plen: 4 vdim: 4
hyper_ratio 0.0625
GraphBLAS type:  int64_t size: 8
number of entries: 4
row: 0 : 2 entries [0:1]
    column 1: int64 10
    column 2: int64 20
row: 2 : 2 entries [2:3]
    column 0: int64 30
    column 2: int64 40</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/abhinavmehndiratta/GraphBLASInterface.jl/blob/5b1613f88ab6669d7f328ee1ba2f6ff68b3cafd6/src/operations/assign.jl#L60-L111">source</a><div><div><pre><code class="language-none">GrB_Matrix_assign(C, Mask, accum, x, I, ni, J, nj, desc)</code></pre><p>Assign the same value to a specified subset of matrix elements. With the use of <code>GrB_ALL</code>, the entire destination matrix can be filled with the constant.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using GraphBLASInterface, SuiteSparseGraphBLAS

julia&gt; GrB_init(GrB_NONBLOCKING)
GrB_SUCCESS::GrB_Info = 0

julia&gt; A = GrB_Matrix{Bool}()
GrB_Matrix{Bool}

julia&gt; GrB_Matrix_new(A, GrB_BOOL, 4, 4)
GrB_SUCCESS::GrB_Info = 0

julia&gt; GrB_Matrix_assign(A, GrB_NULL, GrB_NULL, true, ZeroBasedIndex[0, 1], 2, ZeroBasedIndex[0, 1], 2, GrB_NULL)
GrB_SUCCESS::GrB_Info = 0

julia&gt; GrB_wait()
GrB_SUCCESS::GrB_Info = 0

julia&gt; @GxB_Matrix_fprint(A, GxB_COMPLETE)

GraphBLAS matrix: A
nrows: 4 ncols: 4 max # entries: 4
format: standard CSR vlen: 4 nvec_nonempty: 2 nvec: 4 plen: 4 vdim: 4
hyper_ratio 0.0625
GraphBLAS type:  bool size: 1
number of entries: 4
row: 0 : 2 entries [0:1]
    column 0: bool 1
    column 1: bool 1
row: 1 : 2 entries [2:3]
    column 0: bool 1
    column 1: bool 1</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/abhinavmehndiratta/GraphBLASInterface.jl/blob/5b1613f88ab6669d7f328ee1ba2f6ff68b3cafd6/src/operations/assign.jl#L301-L341">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GraphBLASInterface.GrB_Col_assign" href="#GraphBLASInterface.GrB_Col_assign"><code>GraphBLASInterface.GrB_Col_assign</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">GrB_Col_assign(C, Mask, accum, u, I, ni, j, desc)</code></pre><p>Assign the contents of a vector to a subset of elements in one column of a matrix. Note that since the output cannot be transposed, a different variant of assign is provided to assign to a row of matrix.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using GraphBLASInterface, SuiteSparseGraphBLAS

julia&gt; GrB_init(GrB_NONBLOCKING)
GrB_SUCCESS::GrB_Info = 0

julia&gt; A = GrB_Matrix{Int64}()
GrB_Matrix{Int64}

julia&gt; GrB_Matrix_new(A, GrB_INT64, 4, 4)
GrB_SUCCESS::GrB_Info = 0

julia&gt; I = ZeroBasedIndex[0, 0, 2, 2]; J = ZeroBasedIndex[1, 2, 0, 2]; X = [10, 20, 30, 40]; n = 4;

julia&gt; GrB_Matrix_build(A, I, J, X, n, GrB_FIRST_INT64)
GrB_SUCCESS::GrB_Info = 0

julia&gt; u = GrB_Vector{Int64}()
GrB_Vector{Int64}

julia&gt; GrB_Vector_new(u, GrB_INT64, 2)
GrB_SUCCESS::GrB_Info = 0

julia&gt; I2 = ZeroBasedIndex[0, 1]; X2 = [5, 6]; n2 = 2;

julia&gt; GrB_Vector_build(u, I2, X2, n2, GrB_FIRST_INT64)
GrB_SUCCESS::GrB_Info = 0

julia&gt; GrB_Col_assign(A, GrB_NULL, GrB_NULL, u, ZeroBasedIndex[1, 2], 2, ZeroBasedIndex(0), GrB_NULL)
GrB_SUCCESS::GrB_Info = 0

julia&gt; GrB_wait()
GrB_SUCCESS::GrB_Info = 0

julia&gt; @GxB_Matrix_fprint(A, GxB_COMPLETE)

GraphBLAS matrix: A
nrows: 4 ncols: 4 max # entries: 7
format: standard CSR vlen: 4 nvec_nonempty: 3 nvec: 4 plen: 4 vdim: 4
hyper_ratio 0.0625
GraphBLAS type:  int64_t size: 8
number of entries: 5
row: 0 : 2 entries [0:1]
    column 1: int64 10
    column 2: int64 20
row: 1 : 1 entries [2:2]
    column 0: int64 5
row: 2 : 2 entries [3:4]
    column 0: int64 6
    column 2: int64 40</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/abhinavmehndiratta/GraphBLASInterface.jl/blob/5b1613f88ab6669d7f328ee1ba2f6ff68b3cafd6/src/operations/assign.jl#L124-L183">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GraphBLASInterface.GrB_Row_assign" href="#GraphBLASInterface.GrB_Row_assign"><code>GraphBLASInterface.GrB_Row_assign</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">GrB_Row_assign(C, mask, accum, u, i, J, nj, desc)</code></pre><p>Assign the contents of a vector to a subset of elements in one row of a matrix. Note that since the output cannot be transposed, a different variant of assign is provided to assign to a column of a matrix.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using GraphBLASInterface, SuiteSparseGraphBLAS

julia&gt; GrB_init(GrB_NONBLOCKING)
GrB_SUCCESS::GrB_Info = 0

julia&gt; A = GrB_Matrix{Int64}()
GrB_Matrix{Int64}

julia&gt; GrB_Matrix_new(A, GrB_INT64, 4, 4)
GrB_SUCCESS::GrB_Info = 0

julia&gt; I = ZeroBasedIndex[0, 0, 2, 2]; J = ZeroBasedIndex[1, 2, 0, 2]; X = [10, 20, 30, 40]; n = 4;

julia&gt; GrB_Matrix_build(A, I, J, X, n, GrB_FIRST_INT64)
GrB_SUCCESS::GrB_Info = 0

julia&gt; u = GrB_Vector{Int64}()
GrB_Vector{Int64}

julia&gt; GrB_Vector_new(u, GrB_INT64, 2)
GrB_SUCCESS::GrB_Info = 0

julia&gt; I2 = ZeroBasedIndex[0, 1]; X2 = [5, 6]; n2 = 2;

julia&gt; GrB_Vector_build(u, I2, X2, n2, GrB_FIRST_INT64)
GrB_SUCCESS::GrB_Info = 0

julia&gt; GrB_Row_assign(A, GrB_NULL, GrB_NULL, u, ZeroBasedIndex(0), ZeroBasedIndex[1, 3], 2, GrB_NULL)
GrB_SUCCESS::GrB_Info = 0

julia&gt; GrB_wait()
GrB_SUCCESS::GrB_Info = 0

julia&gt; @GxB_Matrix_fprint(A, GxB_COMPLETE)

GraphBLAS matrix: A
nrows: 4 ncols: 4 max # entries: 7
format: standard CSR vlen: 4 nvec_nonempty: 2 nvec: 4 plen: 4 vdim: 4
hyper_ratio 0.0625
GraphBLAS type:  int64_t size: 8
number of entries: 5
row: 0 : 3 entries [0:2]
    column 1: int64 5
    column 2: int64 20
    column 3: int64 6
row: 2 : 2 entries [3:4]
    column 0: int64 30
    column 2: int64 40</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/abhinavmehndiratta/GraphBLASInterface.jl/blob/5b1613f88ab6669d7f328ee1ba2f6ff68b3cafd6/src/operations/assign.jl#L195-L253">source</a></section><h2><a class="nav-anchor" id="Apply-1" href="#Apply-1">Apply</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GraphBLASInterface.GrB_apply" href="#GraphBLASInterface.GrB_apply"><code>GraphBLASInterface.GrB_apply</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">GrB_apply(C, Mask, accum, op, A, desc)</code></pre><p>Generic matrix/vector apply.</p></div></div><a class="source-link" target="_blank" href="https://github.com/abhinavmehndiratta/GraphBLASInterface.jl/blob/5b1613f88ab6669d7f328ee1ba2f6ff68b3cafd6/src/operations/apply.jl#L1-L5">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GraphBLASInterface.GrB_Vector_apply" href="#GraphBLASInterface.GrB_Vector_apply"><code>GraphBLASInterface.GrB_Vector_apply</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">GrB_Vector_apply(w, mask, accum, op, u, desc)</code></pre><p>Compute the transformation of the values of the elements of a vector using a unary function.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using GraphBLASInterface, SuiteSparseGraphBLAS

julia&gt; GrB_init(GrB_NONBLOCKING)
GrB_SUCCESS::GrB_Info = 0

julia&gt; u = GrB_Vector{Int64}()
GrB_Vector{Int64}

julia&gt; GrB_Vector_new(u, GrB_INT64, 3)
GrB_SUCCESS::GrB_Info = 0

julia&gt; I = ZeroBasedIndex[0, 2]; X = [10, 20]; n = 2;

julia&gt; GrB_Vector_build(u, I, X, n, GrB_FIRST_INT64)
GrB_SUCCESS::GrB_Info = 0

julia&gt; w = GrB_Vector{Int64}()
GrB_Vector{Int64}

julia&gt; GrB_Vector_new(w, GrB_INT64, 3)
GrB_SUCCESS::GrB_Info = 0

julia&gt; GrB_Vector_apply(w, GrB_NULL, GrB_NULL, GrB_AINV_INT64, u, GrB_NULL)
GrB_SUCCESS::GrB_Info = 0

julia&gt; @GxB_fprint(w, GxB_COMPLETE)

GraphBLAS vector: w 
nrows: 3 ncols: 1 max # entries: 2
format: standard CSC vlen: 3 nvec_nonempty: 1 nvec: 1 plen: 1 vdim: 1
hyper_ratio 0.0625
GraphBLAS type:  int64_t size: 8
number of entries: 2 
column: 0 : 2 entries [0:1]
    row 0: int64 -10
    row 2: int64 -20</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/abhinavmehndiratta/GraphBLASInterface.jl/blob/5b1613f88ab6669d7f328ee1ba2f6ff68b3cafd6/src/operations/apply.jl#L9-L53">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GraphBLASInterface.GrB_Matrix_apply" href="#GraphBLASInterface.GrB_Matrix_apply"><code>GraphBLASInterface.GrB_Matrix_apply</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">GrB_Matrix_apply(C, Mask, accum, op, A, desc)</code></pre><p>Compute the transformation of the values of the elements of a matrix using a unary function.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using GraphBLASInterface, SuiteSparseGraphBLAS

julia&gt; GrB_init(GrB_NONBLOCKING)
GrB_SUCCESS::GrB_Info = 0

julia&gt; A = GrB_Matrix{Int64}()
GrB_Matrix{Int64}

julia&gt; GrB_Matrix_new(A, GrB_INT64, 2, 2)
GrB_SUCCESS::GrB_Info = 0

julia&gt; I = ZeroBasedIndex[0, 0, 1]; J = ZeroBasedIndex[0, 1, 1]; X = [10, 20, 30]; n = 3;

julia&gt; GrB_Matrix_build(A, I, J, X, n, GrB_FIRST_INT64)
GrB_SUCCESS::GrB_Info = 0

julia&gt; B = GrB_Matrix{Int64}()
GrB_Matrix{Int64}

julia&gt; GrB_Matrix_new(B, GrB_INT64, 2, 2)
GrB_SUCCESS::GrB_Info = 0

julia&gt; GrB_Matrix_apply(B, GrB_NULL, GrB_NULL, GrB_AINV_INT64, A, GrB_NULL)
GrB_SUCCESS::GrB_Info = 0

julia&gt; @GxB_fprint(B, GxB_COMPLETE)

GraphBLAS matrix: B
nrows: 2 ncols: 2 max # entries: 3
format: standard CSR vlen: 2 nvec_nonempty: 2 nvec: 2 plen: 2 vdim: 2
hyper_ratio 0.0625
GraphBLAS type:  int64_t size: 8
number of entries: 3
row: 0 : 2 entries [0:1]
    column 0: int64 -10
    column 1: int64 -20
row: 1 : 1 entries [2:2]
    column 1: int64 -30</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/abhinavmehndiratta/GraphBLASInterface.jl/blob/5b1613f88ab6669d7f328ee1ba2f6ff68b3cafd6/src/operations/apply.jl#L63-L109">source</a></section><h2><a class="nav-anchor" id="Reduce-1" href="#Reduce-1">Reduce</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GraphBLASInterface.GrB_reduce" href="#GraphBLASInterface.GrB_reduce"><code>GraphBLASInterface.GrB_reduce</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">GrB_reduce(arg1, arg2, arg3, arg4, ...)</code></pre><p>Generic method for matrix/vector reduction to a vector or scalar.</p></div></div><a class="source-link" target="_blank" href="https://github.com/abhinavmehndiratta/GraphBLASInterface.jl/blob/5b1613f88ab6669d7f328ee1ba2f6ff68b3cafd6/src/operations/reduce.jl#L1-L5">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GraphBLASInterface.GrB_Matrix_reduce_Monoid" href="#GraphBLASInterface.GrB_Matrix_reduce_Monoid"><code>GraphBLASInterface.GrB_Matrix_reduce_Monoid</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">GrB_Matrix_reduce_Monoid(w, mask, accum, monoid, A, desc)</code></pre><p>Reduce the entries in a matrix to a vector. By default these methods compute a column vector w such that w(i) = sum(A(i,:)), where &quot;sum&quot; is a commutative and associative monoid with an identity value. A can be transposed, which reduces down the columns instead of the rows.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using GraphBLASInterface, SuiteSparseGraphBLAS

julia&gt; GrB_init(GrB_NONBLOCKING)
GrB_SUCCESS::GrB_Info = 0

julia&gt; A = GrB_Matrix{Int64}()
GrB_Matrix{Int64}

julia&gt; GrB_Matrix_new(A, GrB_INT64, 4, 4)
GrB_SUCCESS::GrB_Info = 0

julia&gt; I = ZeroBasedIndex[0, 0, 2, 2]; J = ZeroBasedIndex[1, 2, 0, 2]; X = [10, 20, 30, 40]; n = 4;

julia&gt; GrB_Matrix_build(A, I, J, X, n, GrB_FIRST_INT64)
GrB_SUCCESS::GrB_Info = 0

julia&gt; w = GrB_Vector{Int64}()
GrB_Vector{Int64}

julia&gt; GrB_Vector_new(w, GrB_INT64, 4)
GrB_SUCCESS::GrB_Info = 0

julia&gt; GrB_Matrix_reduce_Monoid(w, GrB_NULL, GrB_NULL, GxB_PLUS_INT64_MONOID, A, GrB_NULL)
GrB_SUCCESS::GrB_Info = 0

julia&gt; @GxB_fprint(w, GxB_COMPLETE)

GraphBLAS vector: w
nrows: 4 ncols: 1 max # entries: 2
format: standard CSC vlen: 4 nvec_nonempty: 1 nvec: 1 plen: 1 vdim: 1
hyper_ratio 0.0625
GraphBLAS type:  int64_t size: 8
number of entries: 2
column: 0 : 2 entries [0:1]
    row 0: int64 30
    row 2: int64 70</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/abhinavmehndiratta/GraphBLASInterface.jl/blob/5b1613f88ab6669d7f328ee1ba2f6ff68b3cafd6/src/operations/reduce.jl#L11-L57">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GraphBLASInterface.GrB_Matrix_reduce_BinaryOp" href="#GraphBLASInterface.GrB_Matrix_reduce_BinaryOp"><code>GraphBLASInterface.GrB_Matrix_reduce_BinaryOp</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">GrB_Matrix_reduce_BinaryOp(w, mask, accum, op, A, desc)</code></pre><p>Reduce the entries in a matrix to a vector. By default these methods compute a column vector w such that w(i) = sum(A(i,:)), where &quot;sum&quot; is a commutative and associative binary operator. A can be transposed, which reduces down the columns instead of the rows.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using GraphBLASInterface, SuiteSparseGraphBLAS

julia&gt; GrB_init(GrB_NONBLOCKING)
GrB_SUCCESS::GrB_Info = 0

julia&gt; A = GrB_Matrix{Int64}()
GrB_Matrix{Int64}

julia&gt; GrB_Matrix_new(A, GrB_INT64, 4, 4)
GrB_SUCCESS::GrB_Info = 0

julia&gt; I = ZeroBasedIndex[0, 0, 2, 2]; J = ZeroBasedIndex[1, 2, 0, 2]; X = [10, 20, 30, 40]; n = 4;

julia&gt; GrB_Matrix_build(A, I, J, X, n, GrB_FIRST_INT64)
GrB_SUCCESS::GrB_Info = 0

julia&gt; w = GrB_Vector{Int64}()
GrB_Vector{Int64}

julia&gt; GrB_Vector_new(w, GrB_INT64, 4)
GrB_SUCCESS::GrB_Info = 0

julia&gt; GrB_Matrix_reduce_BinaryOp(w, GrB_NULL, GrB_NULL, GrB_TIMES_INT64, A, GrB_NULL)
GrB_SUCCESS::GrB_Info = 0

julia&gt; @GxB_fprint(w, GxB_COMPLETE)

GraphBLAS vector: w
nrows: 4 ncols: 1 max # entries: 2
format: standard CSC vlen: 4 nvec_nonempty: 1 nvec: 1 plen: 1 vdim: 1
hyper_ratio 0.0625
GraphBLAS type:  int64_t size: 8
number of entries: 2
column: 0 : 2 entries [0:1]
    row 0: int64 200
    row 2: int64 1200</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/abhinavmehndiratta/GraphBLASInterface.jl/blob/5b1613f88ab6669d7f328ee1ba2f6ff68b3cafd6/src/operations/reduce.jl#L67-L113">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GraphBLASInterface.GrB_Vector_reduce" href="#GraphBLASInterface.GrB_Vector_reduce"><code>GraphBLASInterface.GrB_Vector_reduce</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">GrB_Vector_reduce(monoid, u, desc)</code></pre><p>Reduce entries in a vector to a scalar. All entries in the vector are &quot;summed&quot; using the reduce monoid, which must be associative (otherwise the results are undefined). If the vector has no entries, the result is the identity value of the monoid.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using GraphBLASInterface, SuiteSparseGraphBLAS

julia&gt; GrB_init(GrB_NONBLOCKING)
GrB_SUCCESS::GrB_Info = 0

julia&gt; u = GrB_Vector{Int64}()
GrB_Vector{Int64}

julia&gt; GrB_Vector_new(u, GrB_INT64, 5)
GrB_SUCCESS::GrB_Info = 0

julia&gt; I = ZeroBasedIndex[0, 2, 4]; X = [10, 20, 30]; n = 3;

julia&gt; GrB_Vector_build(u, I, X, n, GrB_FIRST_INT64)
GrB_SUCCESS::GrB_Info = 0

julia&gt; GrB_Vector_reduce(GxB_MAX_INT64_MONOID, u, GrB_NULL)
30</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/abhinavmehndiratta/GraphBLASInterface.jl/blob/5b1613f88ab6669d7f328ee1ba2f6ff68b3cafd6/src/operations/reduce.jl#L123-L151">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GraphBLASInterface.GrB_Matrix_reduce" href="#GraphBLASInterface.GrB_Matrix_reduce"><code>GraphBLASInterface.GrB_Matrix_reduce</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">GrB_Matrix_reduce(monoid, A, desc)</code></pre><p>Reduce entries in a matrix to a scalar. All entries in the matrix are &quot;summed&quot; using the reduce monoid, which must be associative (otherwise the results are undefined). If the matrix has no entries, the result is the identity value of the monoid.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using GraphBLASInterface, SuiteSparseGraphBLAS

julia&gt; GrB_init(GrB_NONBLOCKING)
GrB_SUCCESS::GrB_Info = 0

julia&gt; A = GrB_Matrix{Int64}()
GrB_Matrix{Int64}

julia&gt; GrB_Matrix_new(A, GrB_INT64, 4, 4)
GrB_SUCCESS::GrB_Info = 0

julia&gt; I = ZeroBasedIndex[0, 0, 2, 2]; J = ZeroBasedIndex[1, 2, 0, 2]; X = [10, 20, 30, 40]; n = 4;

julia&gt; GrB_Matrix_build(A, I, J, X, n, GrB_FIRST_INT64)
GrB_SUCCESS::GrB_Info = 0

julia&gt; GrB_Matrix_reduce(GxB_MIN_INT64_MONOID, A, GrB_NULL)
10</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/abhinavmehndiratta/GraphBLASInterface.jl/blob/5b1613f88ab6669d7f328ee1ba2f6ff68b3cafd6/src/operations/reduce.jl#L158-L186">source</a></section><h2><a class="nav-anchor" id="Transpose-1" href="#Transpose-1">Transpose</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GraphBLASInterface.GrB_transpose" href="#GraphBLASInterface.GrB_transpose"><code>GraphBLASInterface.GrB_transpose</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">GrB_transpose(C, Mask, accum, A, desc)</code></pre><p>Compute a new matrix that is the transpose of the source matrix.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using GraphBLASInterface, SuiteSparseGraphBLAS

julia&gt; GrB_init(GrB_NONBLOCKING)
GrB_SUCCESS::GrB_Info = 0

julia&gt; M = GrB_Matrix{Int64}()
GrB_Matrix{Int64}

julia&gt; GrB_Matrix_new(M, GrB_INT64, 4, 4)
GrB_SUCCESS::GrB_Info = 0

julia&gt; I = ZeroBasedIndex[0, 0]; J = ZeroBasedIndex[1, 2]; X = [10, 20]; n = 2;

julia&gt; GrB_Matrix_build(M, I, J, X, n, GrB_FIRST_INT64)
GrB_SUCCESS::GrB_Info = 0

julia&gt; @GxB_fprint(M, GxB_COMPLETE)

GraphBLAS matrix: M 
nrows: 4 ncols: 4 max # entries: 2
format: standard CSR vlen: 4 nvec_nonempty: 1 nvec: 4 plen: 4 vdim: 4
hyper_ratio 0.0625
GraphBLAS type:  int64_t size: 8
number of entries: 2 
row: 0 : 2 entries [0:1]
    column 1: int64 10
    column 2: int64 20

julia&gt; M_TRAN = GrB_Matrix{Int64}()
GrB_Matrix{Int64}

julia&gt; GrB_Matrix_new(M_TRAN, GrB_INT64, 4, 4)
GrB_SUCCESS::GrB_Info = 0

julia&gt; GrB_transpose(M_TRAN, GrB_NULL, GrB_NULL, M, GrB_NULL)
GrB_SUCCESS::GrB_Info = 0

julia&gt; @GxB_fprint(M_TRAN, GxB_COMPLETE)

GraphBLAS matrix: M_TRAN 
nrows: 4 ncols: 4 max # entries: 2
format: standard CSR vlen: 4 nvec_nonempty: 2 nvec: 4 plen: 4 vdim: 4
hyper_ratio 0.0625
GraphBLAS type:  int64_t size: 8
number of entries: 2 
row: 1 : 1 entries [0:0]
    column 0: int64 10
row: 2 : 1 entries [1:1]
    column 0: int64 20</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/abhinavmehndiratta/GraphBLASInterface.jl/blob/5b1613f88ab6669d7f328ee1ba2f6ff68b3cafd6/src/operations/transpose.jl#L1-L58">source</a></section><footer><hr/><a class="previous" href="../seq_ter/"><span class="direction">Previous</span><span class="title">Sequence termination</span></a></footer></article></body></html>
